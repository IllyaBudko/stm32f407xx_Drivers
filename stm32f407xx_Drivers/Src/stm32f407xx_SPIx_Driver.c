/*
 * stm32f407xx_SPIx_Driver.c
 *
 *  Created on: Jan 18, 2020
 *      Author: Illya Budko
 */

#include "stm32f407xx.h"
#include "stm32f407xx_SPIx_Driver.h"



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//SPIx Helper functions
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//SPIx Get flag status
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint8_t SPI_GetFlagStatus(SPIx_RegDef_t *pSPIx, uint32_t flagName)
{
	if(pSPIx->SR & flagName){
		return FLAG_SET;
	}
	return FLAG_RESET;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//SPIx APIs
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//SPIx Peripheral clock setup
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SPI_Pclk_Init(SPIx_RegDef_t *pSPIx, uint8_t ENorDI)
{
	if(ENorDI == ENABLE) {
		if(pSPIx == SPI1) {
			SPI1_PCLK_EN();
		}
		else if(pSPIx == SPI2) {
			SPI2_PCLK_EN();
		}
		else if(pSPIx == SPI3) {
			SPI3_PCLK_EN();
		}
	}
	else{
		if(pSPIx == SPI1) {
			SPI1_PCLK_DI();
		}
		else if(pSPIx == SPI2) {
			SPI2_PCLK_DI();
		}
		else if(pSPIx == SPI3) {
			SPI3_PCLK_DI();
		}
	}
}

//SPIx Initialization
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SPI_Init(SPIx_Handle_t *pSPIHandle)
{
	SPI_Pclk_Init(pSPIHandle->pSPIx, ENABLE);

	uint32_t tempreg = 0;
	tempreg |= (pSPIHandle->SPIConfig.SPI_DeviceMode) << SPI_CR1_MSTR;
	if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_FD) {
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
	}
	else if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_HD) {
		tempreg |=  (1 << SPI_CR1_BIDIMODE) ;
	}
	else if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_SX_RX) {
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
		tempreg |=  (1 << SPI_CR1_RXONLY);
	}

	tempreg |= (pSPIHandle->SPIConfig.SPI_SClkSpeed) << SPI_CR1_BR;
	tempreg |= (pSPIHandle->SPIConfig.SPI_DFF) << SPI_CR1_DFF;
	tempreg |= (pSPIHandle->SPIConfig.SPI_CPOL) << SPI_CR1_CPOL;
	tempreg |= (pSPIHandle->SPIConfig.SPI_CPHA) << SPI_CR1_CPHA;

	(pSPIHandle->pSPIx->CR1) = tempreg;
}

//SPIx Initialization
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SPI_DeInit(SPIx_RegDef_t *pSPIx)
{
	if(pSPIx == SPI1) {
		SPI1_RESET();
	}
	else if(pSPIx == SPI2) {
		SPI2_RESET();
	}
	else if(pSPIx == SPI3) {
		SPI3_RESET();
	}
}

//SPIx Send Data, blocking call
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SPI_SendData(SPIx_RegDef_t *pSPIx, uint8_t *pTxBuffer, uint32_t Len)
{
	while(Len != 0) {
		while(SPI_GetFlagStatus(pSPIx, SPI_FLAG_TXE) == FLAG_RESET);
		if(pSPIx->CR1 & (1 << SPI_CR1_DFF)) {
			pSPIx->DR = *((int16_t *)pTxBuffer);
			Len--;
			Len--;
			(uint16_t *)pTxBuffer++;
		}
		else {
			pSPIx->DR = *((int8_t *)pTxBuffer);
			Len--;
			pTxBuffer++;
		}
	}
}

//SPIx Receive Data, blocking call
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SPI_ReceiveData (SPIx_RegDef_t *pSPIx, uint8_t *pRxBuffer, uint32_t Len)
{
	while(Len != 0) {
			while(SPI_GetFlagStatus(pSPIx, SPI_FLAG_RXNE) == FLAG_SET);
			if(pSPIx->CR1 & (1 << SPI_CR1_DFF)) {
				*((int16_t *)pRxBuffer) = pSPIx->DR;
				Len--;
				Len--;
				(uint16_t *)pRxBuffer++;
			}
			else {
				*((int8_t *)pRxBuffer) = pSPIx->DR;
				Len--;
				pRxBuffer++;
			}
		}
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//IRQ Configuration and handling APIs
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//IRQ Interrupt configuration APIs
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SPI_IRQInterruptConfig(uint8_t IRQNumber, uint8_t EnorDi)
{
	if(EnorDi == ENABLE){
		if(IRQNumber < 31){
			*NVIC_ISER0 |= (1 << IRQNumber);
		}
		if(IRQNumber > 31 && IRQNumber < 64){
			*NVIC_ISER1 |= (1 << (IRQNumber % 32));
		}
		if(IRQNumber > 64 && IRQNumber < 96){
			*NVIC_ISER2 |= (1 << (IRQNumber % 64));
		}
	}
	else{
		if(IRQNumber < 31){
			*NVIC_ICER0 |= (1 << IRQNumber);
		}
		if(IRQNumber > 31 && IRQNumber < 64){
			*NVIC_ICER1 |= (1 << (IRQNumber % 32));
		}
		if(IRQNumber > 64 && IRQNumber < 96){
			*NVIC_ICER2 |= (1 << (IRQNumber % 64));
		}
	}
}

//IRQ Priority configuration APIs
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SPI_IRQPriorityConfig(uint8_t IRQNumber, uint32_t IRQPriority)
{
	uint8_t iprx = IRQNumber / 4;
	uint8_t iprxSection = IRQNumber % 4;
	uint8_t shiftAmount = (8 * iprxSection) + (8 - NO_PR_BITS_IMPLEMENTED);
	*(NVIC_PR_BASE_ADDR + iprx) |= IRQPriority << shiftAmount;
}

//IRQ Handling APIs
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SPI_IRQHandling(uint8_t PinNumber)
{

}












